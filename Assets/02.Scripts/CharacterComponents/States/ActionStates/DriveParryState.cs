using UnityEngine;

public class DriveParryState : CharacterState
{
    enum ParryPhase { Start, Loop, End }
    ParryPhase _phase;

    private int driveCost = 100;
    private float driveTickCost = 33f;
    private float TickDt => TickMaster.Instance != null ? TickMaster.TICK_INTERVAL : 1 / 60f;
    private int hitDriveCharge = 100;

    [SerializeField] int minActiveFrames = 6;
    int _remain;

    private Skill_SO skill;

    private FxInstance _parryLoopFx;

    public DriveParryState(CharacterFSM f) : base(f) { }

    public override CharacterStateTag? StateTag => CharacterStateTag.DriveParry;

    protected override void OnEnter()
    {
        property.parryDisableFrame = 5;
        _remain = minActiveFrames;

        skill = property.currentSkill;
        if (skill == null) { fsm.RequestTransition("Idle"); return; }

        phys.mode = PhysicsMode.Normal;
        phys.isGravityOn = true;

        const int JUST = 5;
        const int HOLD = 18;

        property.BeginParryWindow(JUST, HOLD);

        _phase = ParryPhase.Start;
        property.BeginParryWindow(JUST, HOLD);

        bool ok = TryPlay(property.characterName + "/" + animCfg.GetClipKey(AnimKey.ParryStart), OnParryStartComplete);
        if (!ok)
        {
            Debug.LogWarning($"[Skill] Animation not found for '{skill.skillName}' : '{skill.animationClipName}'");
            boxApplier.ClearAllBoxes();
            ReturnToNeutral();
            return;
        }

        property.isInputEnabled = true;
        property.isSkillCancelable = false;
        property.ConsumeDriveGauge(driveCost);
        property.isDriveGaugeCharging = false;

        // 이펙트
        int right = property.isFacingRight ? 1 : -1;
        Quaternion rot = Quaternion.identity;
        rot.eulerAngles = new Vector3(right > 0 ? 0f : 180f, 0f, 0f);
        if (FxService.Instance != null) FxService.Instance.Spawn("DriveParryBase", fsm.transform.position, rot);
    }

    protected override void OnTick()
    {
        if (_phase == ParryPhase.Loop)
        {
            if (property.IsParryLocked)
            {
                // 고정 구간: 입력만 버퍼, 스킬 캔슬/이탈 금지
                property.isInputEnabled = false;
                property.isSkillCancelable = false;
                // 여기서는 단순 대기
                return;
            }
            else
            {
                // 해제됨: 정상 입력/캔슬 허용
                property.isInputEnabled = true;
                property.isSkillCancelable = true;

                // 패리 유지 입력 해제/게이지 소진/기타 조건으로 자연 종료라면:
                // RequestNaturalExit();
            }
        }

        property.ConsumeDriveGauge(driveTickCost * TickDt);
        if (property.isExhausted)
        {
            fsm.TransitionTo("Idle");
        }

        if (_remain > 0) { _remain--; return; }

        var d = input.LastInput.attack;

        if ( (d & (AttackKey.MP | AttackKey.MK)) != (AttackKey.MP | AttackKey.MK) )
        {
            fsm.TransitionTo("Idle");
        }
    }

    protected override void OnExit()
    {
        // 상태 빠져나갈 때 입력 잠금 해제
        property.isInputEnabled = true;
        property.isSkillCancelable = false;
        property.currentSkill = null;
        property.isDriveGaugeCharging = true;

        property.ClearParryWindow();

        if (_parryLoopFx != null)
        {
            _parryLoopFx.Despawn();
            _parryLoopFx = null;
        }

        RequestNaturalExit();
    }

    // ---- 충돌 이벤트(히트캔슬/가드캔슬 등) ----
    public override void HandleHit(HitData hit)
    {
        property.ChargeDriveGauge(hitDriveCharge);

        //TODO: 패리사운드, 이펙트, 시간정지, 저스트도 여기서 처리.
    }

    public override void HandleGuard(PhysicsEntity atk, PhysicsEntity def, CollisionData cd)
    {

    }

    public override void HandleThrow(PhysicsEntity atk, PhysicsEntity def, CollisionData cd)
    {

    }

    // ---- 중립 복귀 ----
    private void ReturnToNeutral()
    {
        Play(property.characterName + "/" + animCfg.GetClipKey(AnimKey.Idle));
    }

    void OnParryStartComplete()
    {
        if (_phase != ParryPhase.Start) return;
        EnterParryLoop();
    }

    void EnterParryLoop()
    {
        _phase = ParryPhase.Loop;
        // 루프 재생
        TryPlay(property.characterName + "/" + animCfg.GetClipKey(AnimKey.ParryLoop), null, loop: true);

        // 루프 이펙트
        if (FxService.Instance != null)
        {
            // 캐릭터 루트에 붙이되, 필요하면 본(예: 가슴/손) Transform을 노출해 그쪽에 붙여도 좋음
            var facingRight = property.isFacingRight;
            var localRot = Quaternion.Euler(facingRight ? 0f : 180f, 0f, 0f);

            // 위치는 취향대로. 살짝 위쪽에 띄우는 예시
            _parryLoopFx = FxService.Instance.SpawnAttached(
                key: "DriveParryBase",
                parent: fsm.transform,
                localOffset: new Vector3(0f, 1.0f, 0f),
                localRot: localRot
            );
        }
    }

    void RequestNaturalExit()
    {
        if (_phase == ParryPhase.End) return;
        _phase = ParryPhase.End;

        if (_parryLoopFx != null)
        {
            _parryLoopFx.Despawn();
            _parryLoopFx = null;
        }

        // End는 단발성
        TryPlay(property.characterName + "/" + animCfg.GetClipKey(AnimKey.ParryEnd), ReturnToNeutral, loop: false);
    }
}
